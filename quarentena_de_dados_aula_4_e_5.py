# -*- coding: utf-8 -*-
"""Quarentena de Dados - Aula 4 e 5

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gIpvzI0SqAcCe3IVSTL6vvfFgHGrxmiB

#Importando os dados e verificando as notas
"""

# Commented out IPython magic to ensure Python compatibility.
# Aqui vamos fazer o import do github do Guilherme (Alura)
import pandas as pd
# %precision %.2f
pd.options.display.float_format = '{:,.2f}'.format
dados = pd.read_csv("https://raw.githubusercontent.com/guilhermesilveira/enem-2018/master/MICRODADOS_ENEM_2018_SAMPLE_43278.csv")
dados.head()

#Escolhendo quais colunas eu quero considerar
notas = ["NU_NOTA_CN","NU_NOTA_CH","NU_NOTA_LC","NU_NOTA_MT","NU_NOTA_REDACAO"]

#Buscando essas colunas na base
dados_notas = dados[notas].dropna()
dados_notas.head()

"""# Procurando correlações entre as notas"""

#Renomeando as colunas
dados_notas.columns = ["ciencias_naturais","ciencias_humanas","linguagens_codigos","matematica","redacao"]

#Trazendo as correlações
dados_notas.corr()

#Usando o seaborn correlation matrix para mostrar essas informações

from string import ascii_letters
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Compute the correlation matrix
corr = dados_notas.corr()

# Generate a mask for the upper triangle
mask = np.triu(np.ones_like(corr, dtype=np.bool))

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(11, 9))

# Generate a custom diverging colormap
cmap = sns.diverging_palette(220, 10, as_cmap=True)

# Draw the heatmap with the mask and correct aspect ratio
sns.heatmap(corr, mask=mask, cmap=cmap, vmin=0, center=0,
            square=True, linewidths=.5, cbar_kws={"shrink": .5}, annot=True)

#Também usando o pairplot
sns.pairplot(dados_notas)

#Também usando o pairplot mas agora informando a regressão
sns.pairplot(dados_notas, kind="reg")

"""# Começando a olhar para Machine Learning"""

# Definindo as "entradas" do processo
x = dados_notas[["ciencias_naturais","ciencias_humanas","matematica","redacao"]]
x.head()

# Definindo a "saída", o que meu processo vai retornar
y = dados_notas["linguagens_codigos"]
y.head()

from sklearn.model_selection import train_test_split
import numpy as np

np.random.seed(43627)

x_treino, x_teste, y_treino, y_teste = train_test_split(x,y, random_state=326784)

from sklearn.svm import LinearSVR
modelo = LinearSVR()
modelo.fit(x_treino, y_treino)

predicoes = modelo.predict(x_teste)
predicoes[:5]

y_teste[:5]

import matplotlib.pyplot as plt
plt.figure(figsize=(10,10))
sns.scatterplot(x=y_teste.values,y=predicoes)

from sklearn.tree import DecisionTreeRegressor

modelo = DecisionTreeRegressor()
modelo.fit(x_treino,y_treino)

predicoes = modelo.predict(x_teste)

import matplotlib.pyplot as plt
plt.figure(figsize=(10,10))
sns.scatterplot(x=y_teste.values,y=predicoes)

from sklearn.metrics import mean_squared_error
mean_squared_error(y_teste, predicoes)

from sklearn.dummy import DummyRegressor

modelo_dummy = DummyRegressor()
modelo_dummy.fit(x_treino,y_treino)
predicoes = modelo_dummy.predict(x_teste)

mean_squared_error(y_teste,predicoes)

